## 简介

`C++` 语言的创建初衷是 "a better C"，但是这并不意味着 `C++` 中类似 `C` 语言的全局变量和函数所采用的编译和连接方式与 `C` 语言完全相同。作为一种欲与 `C` 兼容的语言， `C++` 保留了一部分过程式语言的特点（被世人称为"不彻底地面向对象"），因而它可以定义不属于任何类的全局变量和函数。但是， `C++` 毕竟是一种面向对象的程序设计语言，为了支持函数的重载， `C++` 对全局函数的处理方式与 `C` 有明显的不同。

本文将介绍 `C++` 中如何通过 extern "C" 关键字支持 `C` 语言。

### 某企业曾经给出如下的一道面试题

为什么标准头文件都有类似以下的结构？

```c
//incvxworks.h
#ifndef __INCvxWorksh
#define __INCvxWorksh

#ifdef __cplusplus
extern "C" {
#endif

    /*...*/

#ifdef __cplusplus
}
#endif

#endif /* __INCvxWorksh */
```

### 问题分析

对于上面问题，显然，头文件中的编译宏 `#ifndef __INCvxWorksh` 、 `#define __INCvxWorksh` 、 `#endif` 的作用是防止该头文件被重复引用。

那么，

```c
#ifdef __cplusplus
extern "C" {
#endif
和
#ifdef __cplusplus
}
#endif
```

的作用又是什么呢？我们将在后面对此进行详细说明。

### 关于 extern "C"

前面的题目中的 `__cplusplus` 宏，是用来识别编译器的，也就是说，将当前代码编译的时候，是否将代码作为 `C++` 进行编译。如果是，则定义了 `__cplusplus` 宏。更多内容，这里就不详细说明了。

而题目中的 extern "C" 包含双重含义，从字面上即可得到：首先，被它修饰的目标是 `extern` 的；其次，被它修饰的目标是 `C` 的。

具体如下：

**被 extern "C" 限定的函数或变量是 `extern` 类型的。**

`extern` 是 `C/C++` 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。

注意，语句 `extern int a;` 仅仅是对变量的声明，其并不是在定义变量 `a` ，声明变量并未为 `a` 分配内存空间。定义语句形式为 `int a;` ，变量 `a` 在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。

在引用全局变量和函数之前，必须要有这个变量或者函数的声明（或者定义）。通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字 `extern` 声明。例如，如果模块 `B` 欲引用该模块 `A` 中定义的全局变量和函数时只需包含模块 `A` 的头文件即可。这样，模块B中调用模块 `A` 中的函数时，在编译阶段，模块 `B` 虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块 `A` 编译生成的目标代码中找到此函数。

与 `extern` 对应的关键字是 `static` ，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被 extern "C" 修饰。

**被 extern "C" 修饰的变量和函数是按照 `C` 语言方式编译和连接的。**