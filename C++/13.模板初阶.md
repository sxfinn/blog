## 泛型编程

> 如何实现一个通用的交换函数呢？

```cpp
void Swap(int& left, int& right)
{
	int temp = left;
	left = right;
	right = temp;
}
void Swap(double& left, double& right)
{
	double temp = left;
	left = right;
	right = temp;
}
void Swap(char& left, char& right)
{
	char temp = left;
	left = right;
	right = temp;
}
```

C++支持函数重载，因此无论是交换double类型还是int类型的变量的值，可以统一使用同一个函数名。

使用函数重载虽然可以实现，但是有一下几个不好的地方：
1. 重载的函数仅仅是类型不同，代码复用率比较低，只要有新类型出现时，就需要用户自己增加对应的函数。
2. 代码的可维护性比较低，一个出错可能所有的重载均出错。



很显然这些函数只有类型不同，那么我们能否写出一个模型，让编译器根据不同的类型利用模板来生成不同的函数呢？

就像下面的图一样，我们只需要制作模具，后面的事情就简单了许多。

![image-20220723160806842](https://pic.xinsong.xyz/img/202207231608974.png)



> 如果在C++中，也能够存在这样一个模具，通过给这个模具中填充不同材料(类型)，来获得不同材料的铸件(即生成具体类型的代码），那将会节省许多头发。巧的是前人早已将树栽好，我们只需在此乘凉。

**泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。**

![image-20220723160905311](https://pic.xinsong.xyz/img/202207231609334.png)

## 函数模板

### 概念

> 函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。

### 格式

> template<typename T1, typename T2,......,typename Tn>
> return_type 函数名(参数列表){}
>
> ```cpp
> template<typename T>
> void Swap(T& left, T& right)
> {
> 	T temp = left;
> 	left = right;
> 	right = temp;
> }
> ```
>
> **注意**：**typename**是用来定义**模板参数关键字**，也可以使用class(切记：不能使用struct代替class)

### 原理

> 函数模板就像机器人一样，我们将重复简单的事情交给他去做，它可以代替我们完成这些，为我们节省了大量时间和精力。
>
> 函数模板就是一个蓝图

 

















