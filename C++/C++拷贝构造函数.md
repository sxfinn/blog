## 拷贝构造函数

我们经常会用一个变量去初始化一个同类型的变量，那么对于自定义的类型也应该有类似的操作，那么创建对象时如何使用一个已经存在的对象去创建另一个与之相同的对象呢？

> **构造函数：只有单个形参**，该形参是对本类类型对象的引用(一般常用const修饰)，**在用已存在的类类型对象创建新对象时由编译器自动调用**

### 特征

---

拷贝构造也是一个特殊的成员函数

特征如下：

* 拷贝构造是构造函数的一个重载
* 拷贝构造的参数只有一个并且类型必须是该类的引用，而不是使用传值调用，否则会无限递归
* 若没有显式定义拷贝构造函数，编译器会自己生成一个默认拷贝构造，默认的拷贝构造函数对象按按内存存储和字节序完成拷贝，也叫浅拷贝。

```cpp
class Date
{
public:
	Date(int year, int month, int day)
		:
		_year(year),
		_month(month),
		_day(day)
	{}
	void Display()
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1(2001, 7, 28);
	Date d2(d1);
	d1.Display();
	d2.Display();
	return 0;
}
```

> 输出：
>
> 2001-7-28
>
> 2001-7-28

* 对于那些直接管理着内存资源的类（含有指针变量），那么简单的值拷贝还顶得住吗？显然顶不住啊。

通过图示说明：

![image-20220521142159690](https://pic.xinsong.xyz/img/202205211421772.png)

两个string类的对象指向了同一块空间，这不就乱套了吗，如果其中一个对象通过指针改变了指向内存的数据，那么另一个对象也会受到影响，这是我们不愿发生的，我们希望每个对象都能独立运作。

下面这个程序会崩溃

```cpp
class String
{
public:
	String(const char* str = "songxin")
	{
		cout << "String(const char* str = \"songxin\")" << endl;
		_str = (char*)malloc(strlen(str) + 1);
		strcpy(_str, str);
	}
	~String()
	{
		cout << "~String()" << endl;
		free(_str);
		_str = nullptr;
	}
private:
	char* _str;
};
int main()
{
	String s1;
	String s2(s1);
	return 0;
}
```

原因是两个string类的成员指针都指向一块内存，而它们又分别调用了一次析构函数，相当于对同一块内存空间释放了两次，程序崩溃。

因此对于这种情况的对象，我们就不能再使用编译器生成的默认拷贝构造了，而只能自己去显式的定义拷贝构造并且要实现深拷贝。

### 拷贝构造的初始化列表

---

拷贝构造是构造函数的一个重载，因此拷贝构造函数也是有初始化列表的，所以也建议在初始化列表阶段完成对对象的初始化，养成良好习惯。

不需要我们自己写拷贝构造函数的情况

* 成员变量没有指针；
* 成员有指针，但并没有管理内存资源；
