# 2022-05-22-

### 摘要
> 再谈构造函数
>
> static成员
>
> C++11的成员初始化
>
> 友元
>
> 内部类
>
> 再次理解封装

### 总结

> 

目录
---
[TOC]

------

## 再谈构造函数

之前讲过构造函数的一些特性，再在这里补充下。

### 构造函数体赋值

---

```cpp
class Date
{
public:
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
```

在程序进入函数体时，成员变量的初始化实际上已经完成，具有了初始值，虽然为构造函数的函数体，可实际函数体的赋值操作并不是对成员的初始化，而只能算是对成员的赋值操作。并且初始化操作只能由一次而在函数体内却可对一个变量多次赋值，因此**函数体内的赋值操作不能称为初始化操作**。



### 初始化列表

---

> 初始化列表：以一个**冒号开始**，接着是以**逗号分隔**每个成员列表，每个**成员变量后跟一个括号**，括号内为需要初始化的**初值或者表达式**。

```cpp
class Stack
{
public:
	Stack()
		:
		_size(0),
		_capacity(4),//初值
		_p((int*)malloc(sizeof(int) * _capacity))//表达式
	{}		
private:
	
	int _size;
	int _capacity;
	int* _p;
};
int main()
{
	Stack s;
	return 0;
}
```

至于初始化列表是什么，其实就是类的对象的成员定义的地方。

对象的定义大致三个过程：

1. 为类的对象分配内存空间（对象的空间）
2. 在分得的内存空间的基础上初始化成员变量（初始化列表、初始化对象）
3. 初始化结束，对成员变量的赋值（函数体）

例如`Date d1(2001,7,28);`

可以先视作为d1分配空间，然后在此空间的基础上走Date构造的初始化列表，初始化列表结束，即初始化结束。

【注意事项】：

1. 每个成员变量在初始化列表中**只能出现一次**(初始化只能初始化一次)
2. 类中包含以下成员，必须放在初始化列表位置显式进行初始化：
  - [x] 引用成员变量
  - [x] const成员变量
  - [x] 自定义成员变量（该类没有默认构造函数）

```cpp
class A
{
public:
	A(int a)
		:
		_a(a)
	{}
private:
	int _a;
};
int global = 0;
class B
{
public:
	B(int b , int aa)
		:
		_b(b),
		_aa(aa),
		_ref(global)
	{}
private:
	const int _b;//const
	int& _ref;//引用
	A _aa;//没有默认构造函数
};
int main()
{
	B tmp(1, 2);
	return 0;
}
```

3. 尽量使用初始化列表初始化，因为不论你是否使用初始化列表，对于自定义类型成员变量，一定会在初始化列表中初始化。通俗来讲就是初始化列表是一定会走一遍的，我们使用初始化列表只是显式的去调用。

```cpp
#include<iostream>
using namespace std;
class Time
{
public:
	Time(int hour = 0)
		:_hour(hour)
	{
		cout << "Time()" << endl;
	}
private:
	int _hour;
};
class Date
{
public:
	Date(int day)
	{}
private:
	int _day;
	Time _t;
};
int main()
{
	Date d(1);
}
```

在Date的构造函数中我们并没有使用初始化列表，但仍然会在初始化列表里调用_t的默认构造函数，而至于为什么初始化列表不去处理内置类型，可以这样理解：

**在普通的定义int类型时通常会这样定义**：

`int a = 10;`或者`int a;`，第一个会将a初始化为10，第二个则是随机值

**不过也可以用类似于定义自定义类型的方式去定义**：

`int a(10);`显式调用int的构造函数

**注意**：不存在`int a();`这样的定义方式，会被当做函数声明（但在初始化列表里可以写括号但无参，因为初始化列表变量前不带类型，不会被当做函数声明）

**虽然无法像上面这样但有一个匿名变量的写法**：

`int();`，像这样子写会创建一个临时变量，并且值为0，而这和自定义类型的匿名对象方式一样，所以可以看成是**调用了int的默认构造**，而int的默认构造默认初始化成0值。

**所以！！！**大致可认为内置类型的变量有两种初始化方法：

1. 调用了默认构造定义的定义方式；（不给值默认初始化为0）
2. 采用普通的定义方式；（不给值默认随机值）

在类的构造函数的初始化列表中，都是默认以普通的方式去定义内置类型，而不是调用内置类型的默认构造函数，而当我们初始化列表中显式的初始化内置类型时，可以看作调用了其构造函数并且可以给初值，而不再使用其默认的普通定义方式。

（注：在初始化列表中初始化内置类型如果括号里不给值，会被初始化为0，也可以看作是调用了默认构造函数，默认构造默认值为0）

如下：

```cpp
class Time
{
public:
	Time(int hour = 0)
		:_hour(hour)
	{
		cout << "Time()" << endl;
	}
private:
	int _hour;
};
class Date
{
public:
	Date(int day)
		:
		_day(),//内置类型和自定义类型都支持这样地无参初始化，调用了默认构造
		_t()//调用默认构造函数
	{}
private:
	int _day;
	Time _t;
};
```

（个人认为如果这里能把内置类型也在初始化列表也处理了就完美了，既方便又好理解）

**总结**：只要调用了构造函数，就会走一遍初始化列表！！！

**对于内置类型**：

​	不显式的去初始化内置类型，走的是默认的普通内置类型定义方式；

​	显式的去初始化内置类型，走的是内置类型的构造函数，即使不给初值也会是零！

**对于自定义类型**：

​	不显式的去初始化自定义类型，走的是调用其默认构造；

​	显式的去初始化自定义类型，走的是调用其默认构造，并且可以给初始化值；

#### 初始化列表的初始化顺序

成员变量在类中的**声明次序**就是其在初始化列表中**初始化的次序**，而与其初始化列表的先后顺序无关。

```cpp
class A
{
public:
	A(int a)
		:_a1(a)
		, _a2(_a1)
	{}
	void Print()
	{
		cout << _a1 << " " << _a2 << endl;
	}
private:
	int _a2;
	int _a1;
};
int main() 
{
	A aa(1);
	aa.Print();
}
```

以上程序会输出什么？

> A.输出1 1
> B.程序崩溃
> C.编译不通过
> D.输出1  随机值

答案是D，根据声明顺序初始化列表一定会先初始化`_a2`，再初始化 `_a1`，而使用`_a1`初始化`_a2`时 `_a1`还是随机值，因此`_a`会被初始化成随机值，而`_a1`会被初始化为`a`的值——1；

### explicit关键字

----

构造函数不仅可以初始化对象，**对于单个参数的构造函数，还具有类型转换的作用**。

```cpp
class Date
{
public:
	Date(int year)
		:_year(year)
	{}
	explicit Date(int year)
		:_year(year)
	{}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1(2018);
	// 用一个整形变量给日期类型对象赋值
	// 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值
	d1 = 2019;//有explicit修饰构造函数，2019就无法发生隐式转换，这里会报错；
	Date d2 = 2020;//同理
}
```

> 上述代码可读性不是很好，用**explicit修饰构造函数**，将会**禁止单参构造函数的隐式转换**。

如果没有explicit修饰构造函数的话，这里单参构造函数的隐式转换的过程是先将使用2020构造出一个Date临时对象，再调用拷贝构造去对d1进行拷贝，不过经过编译器的优化，通常会将 **构造+拷贝构造** 优化成 **直接使用2020构造d1.**

## static成员

static修饰全局函数，会改变其链接属性，修饰局部变量，会改变其生命周期。

在类中的static成员有什么作用呢？

#### 概念

> 声明为**static的类成员**称为类的**静态成员**，用**static修饰的成员变量**，称之为**静态成员变量**；用**static修饰的成员函数**，称之为**静态成员函数**。**静态的成员变量一定要在类外进行初始化**

static有什么特别之处？来看一个题

> 实现一个类，计算中程序中创建出了多少个类对象。

思路：创建类那么一定会调用构造函数，因此从构造函数和拷贝构造调用了多少次入手，考虑定义一个静态的成员变量`_scount`，每调用一次构造函数，都执行一次 `s_count++`操作，再定义一个函数，用于返回静态变量。

```cpp
class A
{
public:
	A() { ++_scount; }
	A(const A& t) { ++_scount; }
	static int GetACount() { return _scount; }
private:
	static int _scount;
};
int A::_scount = 0;
int main()
{
	A a[10];
	cout << A::GetACount() << endl;
	return 0;
}
```

#### 特性

1. **静态成员属于整个类**，因此为所有类对象所共享，而不属于某个对象；
2. **静态成员变量必须在类外定义**，定义时不添加static关键字，需要指定类域；
3. **类静态成员可用类名::静态成员或者对象.成员来访问**；
4. **静态成员函数没有隐含的this指针**，不能访问任何非静态函数；
5. 静态成员和类的普通成员一样，也有public、private、protected三种访问级别；

对于静态成员，不需要使用对象去调用，而是只要突破了类域限制，就能访问静态成员，对于以上5个特性我们可以尝试解释：

* **对于静态成员变量**，static修饰会让其生命周期延长（存储于静态区），因此需要单独类外定义，类的对象定义时调用构造函数的初始化列表不包括静态成员变量，**静态成员变量不属于某个对象**；

* **对于静态成员函数**，形参列表中没有隐含的this指针，因此不需要对象的地址就能调用，而非静态成员函数由于this指针的存在，即使突破了类域，却仍需要对象的地址才能调用；

【问题】
1. 静态成员函数可以调用非静态成员函数吗？
2. 非静态成员函数可以调用类的静态成员函数吗？

答：**静态成员函数不能调用类的非静态成员函数**，因为静态成员函数没有this指针，而调用非静态成员函数需要传值给this指针。

​		**非静态成员函数可以调用类的静态成员函数**，调用静态成员函数，突破类域即可。

我们前面已经学过static修饰全局函数会改变其链接属性，只能在定义的源文件被调用，那这里被static修饰的成员函数会被改变链接属性吗？

我尝试了一下如下代码：

```cpp
//test.h
class Date
{
public:
	Date()
		:
		_year(1),
		_month(1),
		_day(1)
	{}
	static void test();
private:
	int _year;
	int _month;
	int _day;
};

//test.cpp
#include"date.h"
void Date::test()
{
	cout << "test()" << endl;
}

//main.cpp
#include"date.h"
int main()
{
	Date::test();
	return 0;
}
```

可以正常编译运行调用test函数，但如果test是全局函数，则只能在定义test函数的源文件才能调用test函数，因此static修饰全局函数和修饰成员函数是完全不同的。

总结：

* static修饰类的成员函数，不改变链接属性，仅仅影响隐含的this指针
* static修饰全局函数，改变其链接属性；

## C++11的成员初始化新玩法

---

> C++支持非静态的成员变量在声明时进行初始化赋值，**但是这里不是真正意义上的赋值，这里仅仅只声明，给声明的成员变量缺省值（默认值或者表达式）**。

如下：

```cpp
class Stack
{
public:
	Stack()
        :
    _capacity(8)//这里_capacity会被初始化为8而不是4，我们显式初始化默认值无效。
	{}
private:	
    //非静态成员变量
	int _size = 0;//初始化列表中使用_size(0)初始化
	int _capacity = 4;
	int* _p = (int*)malloc(sizeof(int) * _capacity);//初始化列表中使用_size(malloc)初始化
};
int main()
{
	Stack s;
	return 0;
}
```

实际上这个缺省值是初始化列表的缺省值，对象定义时调用构造函数，初始化列表就会使用这些缺省值去初始化成员变量，**而如果我们自己也写了初始化列表那么缺省值就被覆盖，使用我们给的值去初始化**。

**总结**：类的非静态成员变量声明所给的缺省值，实际上是初始化列表的缺省值，我们不写初始化列表，才会使用这些默认值初始化成员。

值得一提的是只要这个类中有指针类型，那么从一进入构造函数时，在调试窗口看每个成员变量的值都默认为0，直到我们去在初始化列表初始化或者函数体内赋值，用意是什么我也不清楚，可能是为了防止未正确初始化指针变量导致的野指针问题，奇怪奇怪。

## 友元

> 友元分为**友元函数**和**友元类**
>
> 友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。
> 
>例如一些我们定义的全局函数为了能突破类的封装，可以定义为友元函数。

友元一定是万不得已才使用，毕竟会打破封装。



