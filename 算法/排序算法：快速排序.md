# 2022-04-20-

### 摘要
> 

### 总结
> 

目录
---
[TOC]

------

## 快速排序



### 简介

---

**快速排序**是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

**快速排序**使用**分治法**（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！

至于为什么就是比相同时间复杂度的算法快，参考《算法艺术与信息学竞赛》如下信息：

> 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。



### 算法

---

快速排序使用[分治法](https://zh.wikipedia.org/wiki/分治法)（Divide and conquer）策略来把一个[序列](https://zh.wikipedia.org/wiki/序列)（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。

步骤为：

1. 挑选**基准值**：从数列中挑出一个元素，称为“基准”（pivot），
2. 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，
3. 递归排序子序列：[递归](https://zh.wikipedia.org/wiki/递归)地将小于基准值元素的子序列和大于基准值元素的子序列排序。

递归到最底部的判断条件是数列的大小是**零或一**，此时该数列显然已经有序。

选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。

**算法图示：**

![](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204202147425.gif)

#### 挑选基准值

---

选取基准值有数种具体方法，我们从最基本的开始。

基准值是可以任意选取的，那么最简单的我们通常选用待排序序列中的第一个元素作为基准值，但是伴随着一些问题，所以常常采用如下两种方式：

1. 随机选取基准值。
2. 选取区间两端和中间的数据中的中间值作为基准值。

#### 分割

---

**升序序列：**

将比基准值大的数都放在基准值后面，比基准值小的数放在基准值的前面

**降序序列：**

将比基准值大的数都放在基准值前面，比基准值小的数放在基准值的后面

**常用方法：**

1. hoare
2. 挖坑法
3. 快慢双指针

#### 递归子序列

---

**递归的可靠性**

基准的左边全都是小于基准的值，而基准的右边全是大于基准的数，说明基准数在排序后的位置是不变的，那么将左子序列和右子序列分别排序，那么这个序列一定是有序的。于是我们递归调用快排将左子序列和右子序列排序，就可以完成排序。

**结束条件**

如果当前序列已经没有元素或者仅仅只有一个元素，那么我们认为此序列已经有序，无需排序，结束递归。

**递归优化**

1. 三数取中法选基准值
2. 递归序列元素个数较少时采用插入排序

具体原因后面讨论。

### 代码实现

---

既然有用到递归，那么代码通常会比较简洁，我们先统一选取**第一个元素**为基准值作为示范，展示几种不同的方法分割序列。

**hoare**

考虑定义双指针 `left` , `right` 分列数组左右两端，循环执行：

1. 指针 `left` 从左向右寻找比基准值大的数；
2. 指针 `right` 从右向左寻找比基准值小的数；

3. 将偶数 nums[i]nums[i] 和 奇数 nums[j]nums[j] 交换。



可始终保证： 指针 `left` 左边都是小于基准值的数，指针 `right` 右边都是大于基准值的数。

**算法流程：**

1. **初始化：** ii , jj 双指针，分别指向数组 numsnums 左右两端；
2. **循环交换：** 当 i = ji=j 时跳出；
   1. 指针 ii 遇到奇数则执行 i = i + 1i=i+1 跳过，直到找到偶数；
   2. 指针 jj 遇到偶数则执行 j = j - 1j=j−1 跳过，直到找到奇数；
   3. 交换 nums[i]nums[i] 和 nums[j]nums[j] 值；
3. **返回值：** 返回已修改的 numsnums 数组。

















