# 2022-04-18-

### 摘要
> 常用的比较排序算法思想
>
> 算法时间复杂度
>
> 动图示例

### 总结

> 

目录
---
[TOC]

------

## 算法：排序

**排序**是一个非常经典的问题，它以**特定顺序**（递增、非递减（递增或扁平））对数组（或列表）的项目（可以比较，例如整数、浮点数、字符串等）进行重新排序)、递减、非递增（递减或平坦）、字典式等）。

有许多不同的**排序算法**，每一种都有自己的**优点和局限性**。

排序通常用作各种计算机科学课程中的介绍性问题，以展示一系列算法思想。

**以下所以排序都以升序为例.**



### 冒泡排序

---

**冒泡排序**（英语：**Bubble Sort**）又称为**泡式排序**，是一种简单的排序算法。它重复地走访过要排序的[数列](https://zh.wikipedia.org/wiki/数列)，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。



**算法：**

冒泡排序算法的运作如下：

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

**助记码**

参考：[冒泡排序 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)

```
 i∈[0,N-1)               //循环N-1遍
   j∈[0,N-1-i)           //每遍循环要处理的无序部分
     swap(j,j+1)          //两两排序（升序/降序）
```

![img](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204190943593.png)

由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。

**冒泡排序图示：**

![](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204181812177.gif)

每一轮冒泡，会将无序序列中**最大的数**"浮"到无序序列的最后一个位置，此位置成为"有序"，并且为有序序列中的最小值，有序序列的个数增加1，无序序列的个数减1，当**只有一个位置是无序时**，整个数组有序。



**代码实现：**

```

```



**算法分析：**

* 平均时间复杂度



* 最坏时间复杂度



* 最优时间复杂度



* 空间复杂度



**总结：**

冒泡排序对![n](https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b)个项目需要O(n^2^)的比较次数，且可以[原地](https://zh.wikipedia.org/wiki/原地算法)排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。



### 插入排序

---

**插入排序**（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**插入排序**在实现上，通常采用in-place排序（即只需用到**O(1)**的额外空间的排序)，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

**Insertion Sort** 和打扑克牌时非常相似，从牌桌上逐一拿起扑克牌，在手上排序的过程相同。

**举例：**

摸牌顺序: {5 2 4 6 1 3}。

首先拿起第一张牌, 手上有 {5}。

拿起第二张牌 2, 把 2 insert 到手上的牌 {5}, 得到 {2 5}。

拿起第三张牌 4, 把 4 insert 到手上的牌 {2 5}, 得到 {2 4 5}。

以此类推。

**算法：**

一般来说，**插入排序**都采用in-place在数组上实现。具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5



**插入排序图示：**

![](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204181827574.gif)







**代码实现：**

```

```



**算法分析：**

* 平均时间复杂度



* 最坏时间复杂度



* 最优时间复杂度



* 空间复杂度



**总结：**



### Shell排序

---

**希尔排序**（Shellsort），也称**递减增量排序算法**，是[插入排序](https://zh.wikipedia.org/wiki/插入排序)的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- **插入排序**在对几乎已经排好序的数据操作时，效率高，即可以达到[线性排序](https://zh.wikipedia.org/w/index.php?title=線性排序&action=edit&redlink=1)的效率
- 但**插入排序**一般来说是低效的，因为插入排序每次只能将数据移动一位

因此我们可以先对要排序的数组进行**预排序**，让他变成**几乎有序**的状态。

以升序为例，我们的目的是：

* 让大的数更快的到后面
* 让小的数更快的到前面

普通的插入排序是从前到后依次插入，跨度为1，那么为了更快我们可以增加跨度（跨度越大意味着每次插入数据只需要移动较少的次数，便可以大致到它排序后的位置）

希尔排序通过将比较的全部元素分为几个区域来提升[插入排序](https://zh.wikipedia.org/wiki/插入排序)的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的[插入排序](https://zh.wikipedia.org/wiki/插入排序)，但是到了这步，需排序的数据几乎是已排好的了（此时[插入排序](https://zh.wikipedia.org/wiki/插入排序)较快）。

假设有一个很小的数据在一个已按升序排好序的[数组](https://zh.wikipedia.org/wiki/數組)的末端。如果用复杂度为O(*n*2)的排序（[冒泡排序](https://zh.wikipedia.org/wiki/冒泡排序)或[插入排序](https://zh.wikipedia.org/wiki/插入排序)），可能会进行*n*次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

原始数组：

* 长度`length` = 10

![img](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204190910160.png)

* 初始步长 `gap` = `length` / 2 = 5

​		即两个一组，被分为了五组：

​		这和大家军训时教官让大家挨着重复报数 0 或者 1 一样，喊到1的为一组，喊到0的为一组

![img](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204190916290.png)

​																	（同一条线上的为一组）

​		只不过这里是从0报数到4，那么报数相同的分为一组，有不同的5个数，那就是5组咯

​		即步长为多少，就分为多少组。

* 对上面5组数据分别进行插入排序，例如第一组【8，3】，经过插入排序就变成了【3，8】(升序)。

  

​		那么每一组经过排序后就成为了有序序列。

​	结果如下图：

![img](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204190925094.png)

​		

​		可以看到，每一组中较小的数都移动到了前半部分，而较大的数则移动到了后半部分。

* 继续缩小步长 `gap = length / 2 / 2 = 2`

​		即被分为了两组，【3】【5】分别是这两组数组的头部。

​		再对以上两组分别进行**插入排序**

​		例如第一组：【3，1，0，9，7】，经过插入排序后变成【0，1，3，7，9】。

​		两组数据分别排序后结果如图：

![img](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204190932123.png)

​		

​	此时整个数组已经**近乎有序**，大的数集中在数组尾部，小的数集中在数组头部。

​	因此，就可以对整个数组进行直接插入排序即可完成升序排序。

​	继续缩小步长，使`gap` = 1即可，即整个数组为一组，进行直接插入排序，因为数组已经几乎有序，只需要进行	少量调整即可完成排序。



​	**希尔排序示意图：**

![](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204190834381.gif)



**代码实现：**

```

```



**算法分析：**

* 平均时间复杂度

​		根据步长序列的不同而不同。

* 最坏时间复杂度

​		根据步长序列的不同而不同，已知最好的：O(n log^2^(n))

* 最优时间复杂度

​		O(*n*)

* 空间复杂度

​		O(*1*)

**总结：**

步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。



![image-20220419100700092](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204191007136.png)



### 选择排序

---





![](https://cdn.jsdelivr.net/gh/sxfinn/Pic/img/202204181830594.gif)

















